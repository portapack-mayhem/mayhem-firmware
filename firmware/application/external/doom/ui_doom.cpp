/*
 * ------------------------------------------------------------
 * |  Made by RocketGod                                       |
 * |  Find me at https://betaskynet.com                       |
 * |  Argh matey!                                             |
 * ------------------------------------------------------------
 */

 #include "ui_doom.hpp"
 #include "ui.hpp"
 #include "SPI_TFT_ILI9341.h"
 #include "mbed.h"
 
 #define SCREEN_WIDTH 240
 #define SCREEN_HEIGHT 320
 #define RENDER_HEIGHT 280
 #define HALF_WIDTH (SCREEN_WIDTH / 2)
 #define HALF_HEIGHT (RENDER_HEIGHT / 2)
 #define LEVEL_WIDTH_BASE 6
 #define LEVEL_WIDTH (1 << LEVEL_WIDTH_BASE)
 #define LEVEL_HEIGHT 57
 #define LEVEL_SIZE (LEVEL_WIDTH / 2 * LEVEL_HEIGHT)
 #define MAX_RENDER_DEPTH 12
 #define MAX_ENTITIES 10
 #define RES_DIVIDER 2
 #define DISTANCE_MULTIPLIER 20
 #define ROT_SPEED 0.12
 #define MOV_SPEED 0.5
 #define JOGGING_SPEED 0.005
 #define MAX_ENTITY_DISTANCE 200
 #define ITEM_COLLIDER_DIST 6
 #define PI 3.14159265358979323846
 #define GUN_WIDTH 30
 #define GUN_HEIGHT 40
 #define GUN_TARGET_POS 24
 #define GUN_SHOT_POS (GUN_TARGET_POS + 6)
 #define ENEMY_SIZE 16
 #define ENEMY_SPEED 0.02
 #define ENEMY_MELEE_DIST 6
 #define ENEMY_MELEE_DAMAGE 8
 #define GUN_MAX_DAMAGE 15
 
 #define COLOR_BACKGROUND Black
 #define COLOR_WALL Green
 #define COLOR_ENTITY Red
 #define COLOR_PLAYER Blue
 #define COLOR_HUD White
 #define COLOR_WALL_LIGHT Green
 #define COLOR_WALL_DARK Maroon
 #define COLOR_FLOOR_DARK Black
 #define COLOR_FLOOR_LIGHT Orange
 #define COLOR_SKY_DARK Blue
 #define COLOR_SKY_LIGHT Purple
 #define TEXTURE_SCALE 4 
 
 struct Coords {
     double x, y;
 };
 
 struct Player {
     Coords pos;
     Coords dir;
     Coords plane;
     double velocity;
     uint8_t health;
     uint8_t keys;
 };
 
 struct Entity {
     uint16_t uid;
     Coords pos;
     uint8_t state;
     uint8_t health;
     uint8_t distance;
     uint8_t timer;
 };
 
 static const uint8_t level[LEVEL_SIZE] = {
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x02, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x2F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x20, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x90, 0xFF, 0xFF, 0xFF, 0x4F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xF2, 0x00, 0x00, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0x4F, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0x4F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x20, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x02, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0x05, 0x00, 0x00, 0x90, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x00, 0x20, 0x00, 0xFF,
     0xF0, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x08, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF2, 0x02, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0x40, 0x80, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
     0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x40, 0x00, 0x02, 0x00, 0x90, 0xFF, 0xFF,
     0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
     0xF0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x50, 0x00, 0x20, 0x00, 0x7F, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF,
     0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0x00, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x0F, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x40, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
 };
 
 namespace ui::external_app::doom {
 
 static Ticker game_timer;
 static Player player;
 static Entity entities[MAX_ENTITIES];
 static uint8_t num_entities = 0;
 static uint8_t scene = 0;
 static bool up, down, left, right, fired;
 static double jogging, view_height;
 static bool needs_redraw = false;
 static uint8_t gun_pos = GUN_TARGET_POS;
 static bool gun_fired = false;
 
 Coords create_coords(double x, double y) {
     Coords c;
     c.x = x;
     c.y = y;
     return c;
 }
 
 Player create_player(double x, double y) {
    Player p;
    p.pos = create_coords(x + 0.5, y + 0.5);
    p.dir = create_coords(1, 0);
    p.plane = create_coords(0, -0.66);
    p.velocity = 0;
    p.health = 100;
    p.keys = 0;
    return p;
}
 
 Entity create_entity(uint8_t type, uint8_t x, uint8_t y, uint8_t state, uint8_t health) {
     Entity e;
     e.uid = ((y << 6) | x) << 4 | type;
     e.pos = create_coords(x + 0.5, y + 0.5);
     e.state = state;
     e.health = health;
     e.distance = 0;
     e.timer = 0;
     return e;
 }
 
 uint8_t get_block_at(uint8_t x, uint8_t y) {
     if (x >= LEVEL_WIDTH || y >= LEVEL_HEIGHT) return 0xF;
     return level[((LEVEL_HEIGHT - 1 - y) * LEVEL_WIDTH + x) / 2] >> (!(x % 2) * 4) & 0b1111;
 }
 
 void initialize_level() {
     for (uint8_t y = LEVEL_HEIGHT - 1; y > 0; y--) {
         for (uint8_t x = 0; x < LEVEL_WIDTH; x++) {
             uint8_t block = get_block_at(x, y);
             if (block == 0x1) {
                 player = create_player(x, y);
                 return;
             }
         }
     }
 }
 
 Coords translate_into_view(Coords pos) {
     double sprite_x = pos.x - player.pos.x;
     double sprite_y = pos.y - player.pos.y;
     double inv_det = 1.0 / (player.plane.x * player.dir.y - player.dir.x * player.plane.y);
     double transform_x = inv_det * (player.dir.y * sprite_x - player.dir.x * sprite_y);
     double transform_y = inv_det * (-player.plane.y * sprite_x + player.plane.x * sprite_y);
     return create_coords(transform_x, transform_y);
 }
 
 void spawn_entity(uint8_t type, uint8_t x, uint8_t y) {
     if (num_entities >= MAX_ENTITIES) return;
     entities[num_entities] = create_entity(type, x, y, 0, 50);
     num_entities++;
 }
 
 void remove_entity(uint8_t index) {
     for (uint8_t i = index; i < num_entities - 1; i++) {
         entities[i] = entities[i + 1];
     }
     num_entities--;
 }
 
 void fire() {
     for (uint8_t i = 0; i < num_entities; i++) {
         if (entities[i].state == 5) continue;
         Coords transform = translate_into_view(entities[i].pos);
         if (fabs(transform.x) < 20 && transform.y > 0) {
             uint8_t damage = fmin(GUN_MAX_DAMAGE, GUN_MAX_DAMAGE / (fabs(transform.x) * entities[i].distance) / 5);
             if (damage > 0) {
                 entities[i].health = fmax(0, entities[i].health - damage);
                 entities[i].state = 4;
                 entities[i].timer = 4;
             }
         }
     }
 }
 
 void update_entities() {
     uint8_t i = 0;
     while (i < num_entities) {
         entities[i].distance = sqrt(pow(player.pos.x - entities[i].pos.x, 2) + pow(player.pos.y - entities[i].pos.y, 2)) * DISTANCE_MULTIPLIER;
         if (entities[i].timer > 0) entities[i].timer--;
         if (entities[i].distance > MAX_ENTITY_DISTANCE) {
             remove_entity(i);
             continue;
         }
         if (entities[i].health == 0) {
             if (entities[i].state != 5) {
                 entities[i].state = 5;
                 entities[i].timer = 6;
             }
         } else if (entities[i].state == 4) {
             if (entities[i].timer == 0) {
                 entities[i].state = 0;
             }
         } else if (entities[i].distance <= ENEMY_MELEE_DIST) {
             if (entities[i].state != 3) {
                 entities[i].state = 3;
                 entities[i].timer = 10;
             } else if (entities[i].timer == 0) {
                 player.health = fmax(0, player.health - ENEMY_MELEE_DAMAGE);
                 entities[i].timer = 14;
                 needs_redraw = true;
             }
         } else {
             double dx = player.pos.x - entities[i].pos.x;
             double dy = player.pos.y - entities[i].pos.y;
             double dist = sqrt(dx * dx + dy * dy);
             entities[i].pos.x += (dx / dist) * ENEMY_SPEED;
             entities[i].pos.y += (dy / dist) * ENEMY_SPEED;
             if (get_block_at((uint8_t)entities[i].pos.x, (uint8_t)entities[i].pos.y) == 0xF) {
                 entities[i].pos.x -= (dx / dist) * ENEMY_SPEED;
                 entities[i].pos.y -= (dy / dist) * ENEMY_SPEED;
             }
         }
         i++;
     }
 }
 
 void update_game() {
    bool state_changed = false;

    if (scene == 1) {
        if (player.health > 0) {
            if (up) {
                player.velocity += (MOV_SPEED - player.velocity) * 0.4;
                jogging = fabs(player.velocity) * 5;
                up = false;
                state_changed = true;
            } else if (down) {
                player.velocity += (-MOV_SPEED - player.velocity) * 0.4;
                jogging = fabs(player.velocity) * 5;
                down = false;
                state_changed = true;
            } else {
                double old_velocity = player.velocity;
                player.velocity *= 0.5;
                jogging = fabs(player.velocity) * 5;
                if (fabs(player.velocity) < 0.001) player.velocity = 0;
                if (old_velocity != player.velocity) state_changed = true;
            }

            if (right) {
                double old_dir_x = player.dir.x;
                player.dir.x = player.dir.x * cos(-ROT_SPEED) - player.dir.y * sin(-ROT_SPEED);
                player.dir.y = old_dir_x * sin(-ROT_SPEED) + player.dir.y * cos(-ROT_SPEED);
                double old_plane_x = player.plane.x;
                player.plane.x = player.plane.x * cos(-ROT_SPEED) - player.plane.y * sin(-ROT_SPEED);
                player.plane.y = old_plane_x * sin(-ROT_SPEED) + player.plane.y * cos(-ROT_SPEED);
                right = false;
                state_changed = true;
            } else if (left) {
                double old_dir_x = player.dir.x;
                player.dir.x = player.dir.x * cos(ROT_SPEED) - player.dir.y * sin(ROT_SPEED);
                player.dir.y = old_dir_x * sin(ROT_SPEED) + player.dir.y * cos(ROT_SPEED);
                double old_plane_x = player.plane.x;
                player.plane.x = player.plane.x * cos(ROT_SPEED) - player.plane.y * sin(ROT_SPEED);
                player.plane.y = old_plane_x * sin(ROT_SPEED) + player.plane.y * cos(ROT_SPEED);
                left = false;
                state_changed = true;
            }

            if (player.velocity != 0) {
                view_height = fabs(sin(LPC_RTC->CTIME0 * JOGGING_SPEED)) * 6 * jogging;
            } else {
                view_height = 0;
            }

            if (fabs(player.velocity) > 0.003) {
                double new_x = player.pos.x + player.dir.x * player.velocity;
                double new_y = player.pos.y + player.dir.y * player.velocity;
                if (get_block_at((uint8_t)new_x, (uint8_t)player.pos.y) != 0xF) {
                    player.pos.x = new_x;
                    state_changed = true;
                }
                if (get_block_at((uint8_t)player.pos.x, (uint8_t)new_y) != 0xF) {
                    player.pos.y = new_y;
                    state_changed = true;
                }
            } else if (player.velocity != 0) {
                player.velocity = 0;
                state_changed = true;
            }

            if (gun_pos > GUN_TARGET_POS) {
                gun_pos -= 1;
                state_changed = true;
            } else if (gun_pos < GUN_TARGET_POS) {
                gun_pos += 2;
                state_changed = true;
            } else if (!gun_fired && fired) {
                gun_pos = GUN_SHOT_POS;
                gun_fired = true;
                fired = false;
                fire();
                state_changed = true;
            } else if (gun_fired && !fired) {
                gun_fired = false;
                state_changed = true;
            }
        } else {
            if (view_height > -10) {
                view_height--;
                state_changed = true;
            }
            if (gun_pos > 1) {
                gun_pos -= 2;
                state_changed = true;
            }
        }
        update_entities();
    }

    if (state_changed) needs_redraw = true;
}
 
 static void game_timer_check() {
     if (scene == 1) update_game();
 }
 
 void render_gun(Painter& painter, uint8_t gun_pos, double jogging) {
    int x = HALF_WIDTH - GUN_WIDTH / 2 + sin(LPC_RTC->CTIME0 * JOGGING_SPEED) * 10 * jogging;
    int y = RENDER_HEIGHT - gun_pos + fabs(cos(LPC_RTC->CTIME0 * JOGGING_SPEED)) * 8 * jogging;

    painter.fill_rectangle({x + 8, y, 14, 18}, pp_colors[Blue]);
    painter.fill_rectangle({x + 10, y + 18, 12, 10}, pp_colors[Blue]);
    painter.fill_rectangle({x + 12, y + 28, 8, 12}, pp_colors[Blue]);
    painter.fill_rectangle({x + 10, y - 2, 8, 2}, pp_colors[White]);
    painter.fill_rectangle({x + 8, y + 2, 2, 14}, pp_colors[White]);
    painter.fill_rectangle({x + 20, y + 2, 2, 14}, pp_colors[Black]);
    painter.fill_rectangle({x + 10, y + 18, 2, 8}, pp_colors[White]);
    painter.fill_rectangle({x + 20, y + 18, 2, 8}, pp_colors[Black]);
    painter.fill_rectangle({x + 12, y + 28, 2, 10}, pp_colors[White]);
    painter.fill_rectangle({x + 18, y + 28, 2, 10}, pp_colors[Black]);
    painter.fill_rectangle({x + 18, y + 12, 8, 8}, pp_colors[Blue]);
    painter.fill_rectangle({x + 20, y + 14, 4, 4}, pp_colors[Black]);

    if (gun_pos > GUN_TARGET_POS) {
        painter.fill_rectangle({x + 14, y - 6, 6, 4}, pp_colors[Yellow]);
    }
}
 
 void render_entities(Painter& painter) {
     for (uint8_t i = 0; i < num_entities; i++) {
         Coords transform = translate_into_view(entities[i].pos);
         if (transform.y <= 0.1 || transform.y > MAX_RENDER_DEPTH) continue;
         int16_t sprite_x = HALF_WIDTH * (1.0 + transform.x / transform.y);
         int16_t sprite_y = HALF_HEIGHT + view_height / transform.y;
         uint8_t size = ENEMY_SIZE / transform.y;
         if (sprite_x < -size || sprite_x > SCREEN_WIDTH + size) continue;
         if (entities[i].state == 5 && entities[i].timer == 0) {
             painter.fill_rectangle({sprite_x - size / 2, sprite_y, size, size / 2}, pp_colors[COLOR_ENTITY]);
         } else {
             painter.fill_rectangle({sprite_x - size / 2, sprite_y - size / 2, size, size}, pp_colors[COLOR_ENTITY]);
         }
     }
 }
 
 void render_map(Painter& painter, bool full_clear) {
    if (full_clear) {
        painter.fill_rectangle({0, 0, SCREEN_WIDTH, RENDER_HEIGHT / 2}, Color(64, 64, 128));
        painter.fill_rectangle({0, RENDER_HEIGHT / 2, SCREEN_WIDTH, RENDER_HEIGHT / 2}, Color(32, 32, 32));
    }

    for (uint8_t x = 0; x < SCREEN_WIDTH; x += RES_DIVIDER) {
        double camera_x = 2 * (double)x / SCREEN_WIDTH - 1;
        double ray_x = player.dir.x + player.plane.x * camera_x;
        double ray_y = player.dir.y + player.plane.y * camera_x;
        uint8_t map_x = (uint8_t)player.pos.x;
        uint8_t map_y = (uint8_t)player.pos.y;
        double delta_x = fabs(1 / ray_x);
        double delta_y = fabs(1 / ray_y);

        int8_t step_x, step_y;
        double side_x, side_y;

        if (ray_x < 0) {
            step_x = -1;
            side_x = (player.pos.x - map_x) * delta_x;
        } else {
            step_x = 1;
            side_x = (map_x + 1.0 - player.pos.x) * delta_x;
        }
        if (ray_y < 0) {
            step_y = -1;
            side_y = (player.pos.y - map_y) * delta_y;
        } else {
            step_y = 1;
            side_y = (map_y + 1.0 - player.pos.y) * delta_y;
        }

        uint8_t depth = 0;
        bool hit = false;
        bool side;
        while (!hit && depth < MAX_RENDER_DEPTH) {
            if (side_x < side_y) {
                side_x += delta_x;
                map_x += step_x;
                side = false;
            } else {
                side_y += delta_y;
                map_y += step_y;
                side = true;
            }
            uint8_t block = get_block_at(map_x, map_y);
            if (block == 0xF) {
                hit = true;
            } else if (block == 0x2) {
                double distance = sqrt(pow(map_x - player.pos.x, 2) + pow(map_y - player.pos.y, 2)) * DISTANCE_MULTIPLIER;
                if (distance < MAX_ENTITY_DISTANCE) {
                    bool exists = false;
                    for (uint8_t i = 0; i < num_entities; i++) {
                        if (entities[i].uid == ((((uint8_t)map_y << 6) | (uint8_t)map_x) << 4 | 0x2)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) spawn_entity(0x2, map_x, map_y);
                }
            }
            depth++;
        }

        int start_y = 0;
        int end_y = RENDER_HEIGHT;
        double distance = 0;
        if (hit) {
            distance = side ? (map_y - player.pos.y + (1 - step_y) / 2) / ray_y : (map_x - player.pos.x + (1 - step_x) / 2) / ray_x;
            distance = fmax(1, distance);
        } else if (depth < 2) {
            uint8_t check_x = (uint8_t)(player.pos.x + ray_x);
            uint8_t check_y = (uint8_t)(player.pos.y + ray_y);
            if (get_block_at(check_x, map_y) == 0xF || get_block_at(map_x, check_y) == 0xF) {
                distance = sqrt(pow(check_x - player.pos.x, 2) + pow(check_y - player.pos.y, 2));
                distance = fmax(1, distance);
                hit = true;
            }
        }

        if (hit) {
            uint8_t line_height = RENDER_HEIGHT / distance;
            start_y = view_height / distance - line_height / 2 + RENDER_HEIGHT / 2;
            end_y = view_height / distance + line_height / 2 + RENDER_HEIGHT / 2;
            if (start_y < 0) start_y = 0;
            if (end_y > RENDER_HEIGHT) end_y = RENDER_HEIGHT;

            uint8_t brightness = fmax(64, 255 - (distance * 20));
            uint8_t noise = ((map_x * 17 + map_y * 23) & 0x0F);
            Color wall_color = Color(brightness / 4, brightness - noise, brightness / 4);
            painter.fill_rectangle({x, start_y, RES_DIVIDER, end_y - start_y}, wall_color);
        }

        if (!full_clear && hit) {
            if (start_y > 0) {
                painter.fill_rectangle({x, 0, RES_DIVIDER, start_y}, Color(64, 64, 128));
            }
            if (end_y < RENDER_HEIGHT) {
                painter.fill_rectangle({x, end_y, RES_DIVIDER, RENDER_HEIGHT - end_y}, Color(32, 32, 32));
            }
        }
    }
}
 
 DoomView::DoomView(NavigationView& nav) : nav_{nav} {
     add_children({&dummy});
     game_timer.attach(&game_timer_check, 1.0 / 30.0);
 }
 
 void DoomView::on_show() {
     dummy.focus();
 }
 
 void DoomView::paint(Painter& painter) {
     if (!initialized) {
         initialized = true;
         std::srand(LPC_RTC->CTIME0);
         scene = 0;
         up = down = left = right = fired = false;
         jogging = view_height = 0;
         gun_pos = GUN_TARGET_POS;
         gun_fired = false;
         num_entities = 0;
         painter.fill_rectangle({0, 0, SCREEN_WIDTH, SCREEN_HEIGHT}, pp_colors[COLOR_BACKGROUND]);
         needs_redraw = true;
     }
 
     if (scene == 0) {
         auto style_yellow = *ui::Theme::getInstance()->fg_yellow;
         painter.draw_string({50, 40}, style_yellow, "* * * DOOM * * *");
         auto style_green = *ui::Theme::getInstance()->fg_green;
         painter.draw_string({15, 240}, style_green, "** PRESS SELECT TO START **");
     } else if (scene == 1) {
         bool full_clear = needs_redraw && (player.velocity == 0 || !prev_velocity_moving);
         render_map(painter, full_clear);
         render_entities(painter);
         render_gun(painter, gun_pos, jogging);
         painter.fill_rectangle({0, RENDER_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - RENDER_HEIGHT}, pp_colors[COLOR_BACKGROUND]);
         auto style_green = *ui::Theme::getInstance()->fg_green;
         painter.draw_string({5, RENDER_HEIGHT + 5}, style_green, "Health: " + std::to_string(player.health));
         prev_velocity_moving = (player.velocity != 0);
         needs_redraw = false;
     }
 }
 
 void DoomView::frame_sync() {
     if (scene == 1) {
         update_game();
         if (needs_redraw) set_dirty();
     }
 }
 
 bool DoomView::on_key(const KeyEvent key) {
     if (key == KeyEvent::Select && scene == 0) {
         scene = 1;
         initialize_level();
         needs_redraw = true;
         set_dirty();
         return true;
     }
     if (scene == 1) {
         if (player.health > 0) {
             if (key == KeyEvent::Up) {
                 up = true;
                 needs_redraw = true;
                 set_dirty();
                 return true;
             }
             if (key == KeyEvent::Down) {
                 down = true;
                 needs_redraw = true;
                 set_dirty();
                 return true;
             }
             if (key == KeyEvent::Left) {
                 left = true;
                 needs_redraw = true;
                 set_dirty();
                 return true;
             }
             if (key == KeyEvent::Right) {
                 right = true;
                 needs_redraw = true;
                 set_dirty();
                 return true;
             }
             if (key == KeyEvent::Select) {
                 fired = true;
                 needs_redraw = true;
                 set_dirty();
                 return true;
             }
         } else if (key == KeyEvent::Select) {
             scene = 0;
             initialized = false;
             needs_redraw = true;
             set_dirty();
             return true;
         }
     }
     return false;
 }
 
 }  // namespace ui::external_app::doom